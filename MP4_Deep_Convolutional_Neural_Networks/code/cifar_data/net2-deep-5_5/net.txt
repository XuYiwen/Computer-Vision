%% Define network 
% The part you have to modify
net.layers = {} ;
% assume input size 32 * 32
% conv1, output size 32 * 32
net.layers{end+1} = struct('type', 'conv', ...
  'filters', 5e-2*randn(5,5,3,96, 'single'), ...
  'biases', zeros(1, 96, 'single'), ...
  'filtersLearningRate', 1, ...
  'biasesLearningRate', 2, ...
  'stride', 1, ...
  'pad', 2) ;

% conv1x1_1, output size 32 * 32
net.layers{end+1} = struct('type', 'conv', ...
  'filters', 5e-2*randn(1,1,96,80, 'single'), ...
  'biases', zeros(1, 80, 'single'), ...
  'filtersLearningRate', 1, ...
  'biasesLearningRate', 2, ...
  'stride', 1, ...
  'pad', 0) ;

net.layers{end+1} = struct('type', 'relu') ;  

% conv1x1_2, output size 32 * 32
net.layers{end+1} = struct('type', 'conv', ...
  'filters', 5e-2*randn(1,1,80,48, 'single'), ...
  'biases', zeros(1, 48, 'single'), ...
  'filtersLearningRate', 1, ...
  'biasesLearningRate', 2, ...
  'stride', 1, ...
  'pad', 0) ;  

net.layers{end+1} = struct('type', 'relu') ;

% pool1 (max pool), output size 16 * 16
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [2 2], ...
                           'stride', 2, ...
                           'pad', 0) ;

net.layers{end+1} = struct('type', 'dropout', ...
                           'rate', 0.5) ;

% conv2
net.layers{end+1} = struct('type', 'conv', ...
  'filters', 5e-2*randn(5,5,48,96, 'single'), ...
  'biases', zeros(1, 96, 'single'), ...
  'filtersLearningRate', 1, ...
  'biasesLearningRate', 2, ...
  'stride', 1, ...
  'pad', 2) ;

% conv1x1_3
net.layers{end+1} = struct('type', 'conv', ...
  'filters', 5e-2*randn(1,1,96,96, 'single'), ...
  'biases', zeros(1, 96, 'single'), ...
  'filtersLearningRate', 1, ...
  'biasesLearningRate', 2, ...
  'stride', 1, ...
  'pad', 0) ;

net.layers{end+1} = struct('type', 'relu') ;

% conv1x1_4
net.layers{end+1} = struct('type', 'conv', ...
  'filters', 5e-2*randn(1,1,96,96, 'single'), ...
  'biases', zeros(1, 96, 'single'), ...
  'filtersLearningRate', 1, ...
  'biasesLearningRate', 2, ...
  'stride', 1, ...
  'pad', 0) ;

net.layers{end+1} = struct('type', 'relu') ;

% pool2 (max pool), output size 8 * 8
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [2 2], ...
                           'stride', 2, ...
                           'pad', 0) ;   
% dropout_pool2
net.layers{end+1} = struct('type', 'dropout', ...
                           'rate', 0.5) ;    

% conv3
net.layers{end+1} = struct('type', 'conv', ...
  'filters', 5e-2*randn(3,3,96,96, 'single'), ...
  'biases', zeros(1, 96, 'single'), ...
  'filtersLearningRate', 1, ...
  'biasesLearningRate', 2, ...
  'stride', 1, ...
  'pad', 1) ;

% conv1x1_5
net.layers{end+1} = struct('type', 'conv', ...
  'filters', 5e-2*randn(1,1,96,96, 'single'), ...
  'biases', zeros(1, 96, 'single'), ...
  'filtersLearningRate', 1, ...
  'biasesLearningRate', 2, ...
  'stride', 1, ...
  'pad', 0) ;

net.layers{end+1} = struct('type', 'relu') ;

% conv1x1_6
net.layers{end+1} = struct('type', 'conv', ...
  'filters', 5e-2*randn(1,1,96,100, 'single'), ...
  'biases', zeros(1, 100, 'single'), ...
  'filtersLearningRate', 1, ...
  'biasesLearningRate', 2, ...
  'stride', 1, ...
  'pad', 0) ;

net.layers{end+1} = struct('type', 'relu') ;

% pool3 (avg pool), output size 1 * 1
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'avg', ...
                           'pool', [8 8], ...
                           'stride', 2, ...
                           'pad', 0) ;      

% loss
net.layers{end+1} = struct('type', 'softmaxloss') ;